print('Add your SINGLE assembly line(like: \'sub $t0, $t1, $t2\') here:')
assembly_line = input()

registers_dict = {
    '$a0': 4,
    '$a1': 5,
    '$a2': 6,
    '$a3': 7,
    '$at': 1,
    '$fp': 30,
    '$gp': 28,
    '$k0': 26,
    '$k1': 27,
    '$ra': 31,
    '$s0': 16,
    '$s1': 17,
    '$s2': 18,
    '$s3': 19,
    '$s4': 20,
    '$s5': 21,
    '$s6': 22,
    '$s7': 23,
    '$sp': 29,
    '$t0': 8,
    '$t1': 9,
    '$t2': 10,
    '$t3': 11,
    '$t4': 12,
    '$t5': 13,
    '$t6': 14,
    '$t7': 15,
    '$t8': 24,
    '$t9': 25,
    '$v0': 2,
    '$v1': 3,
    '$zero': 0}
token_delimiter = ' '
instructions = {
    'add': {   'funct': '100000',
               'meaning': 'Add',
               'opcode': '000000',
               'type': 'R'},
    'addi': {   'funct': 'NA',
                'meaning': 'Add Immediate',
                'opcode': '001000',
                'type': 'I'},
    'addiu': {   'funct': 'NA',
                 'meaning': 'Add Unsigned Immediate',
                 'opcode': '001001',
                 'type': 'I'},
    'addu': {   'funct': '100001',
                'meaning': 'Add Unsigned',
                'opcode': '000000',
                'type': 'R'},
    'and': {   'funct': '100100',
               'meaning': 'Bitwise AND',
               'opcode': '000000',
               'type': 'R'},
    'andi': {   'funct': 'NA',
                'meaning': 'Bitwise AND Immediate',
                'opcode': '001100',
                'type': 'I'},
    'beq': {   'funct': 'NA',
               'meaning': 'Branch if Equal',
               'opcode': '000100',
               'type': 'I'},
    'blez': {   'funct': 'NA',
                'meaning': 'Branch if Less Than or Equal to Zero',
                'opcode': '000110',
                'type': 'I'},
    'bne': {   'funct': 'NA',
               'meaning': 'Branch if Not Equal',
               'opcode': '000101',
               'type': 'I'},
    'div': {   'funct': '011010',
               'meaning': 'Divide',
               'opcode': '000000',
               'type': 'R'},
    'divu': {   'funct': '011011',
                'meaning': 'Unsigned Divide',
                'opcode': '000000',
                'type': 'R'},
    'j': {   'funct': 'NA',
             'meaning': 'Jump to Address',
             'opcode': '000010',
             'type': 'J'},
    'jal': {   'funct': 'NA',
               'meaning': 'Jump and Link',
               'opcode': '000011',
               'type': 'J'},
    'jr': {   'funct': '001000',
              'meaning': 'Jump to Address in Register',
              'opcode': '000000',
              'type': 'R'},
    'lbu': {   'funct': 'NA',
               'meaning': 'Load Byte Unsigned',
               'opcode': '100100',
               'type': 'I'},
    'lhu': {   'funct': 'NA',
               'meaning': 'Load Halfword Unsigned',
               'opcode': '100101',
               'type': 'I'},
    'lui': {   'funct': 'NA',
               'meaning': 'Load Upper Immediate',
               'opcode': '001111',
               'type': 'I'},
    'lw': {   'funct': 'NA',
              'meaning': 'Load Word',
              'opcode': '100011',
              'type': 'I'},
    'mfc0': {   'funct': 'NA',
                'meaning': 'Move from Coprocessor 0',
                'opcode': '010000',
                'type': 'R'},
    'mfhi': {   'funct': '010000',
                'meaning': 'Move from HI Register',
                'opcode': '000000',
                'type': 'R'},
    'mflo': {   'funct': '010010',
                'meaning': 'Move from LO Register',
                'opcode': '000000',
                'type': 'R'},
    'mult': {   'funct': '011000',
                'meaning': 'Multiply',
                'opcode': '000000',
                'type': 'R'},
    'multu': {   'funct': '011001',
                 'meaning': 'Unsigned Multiply',
                 'opcode': '000000',
                 'type': 'R'},
    'nor': {   'funct': '100111',
               'meaning': 'Bitwise NOR (NOT-OR)',
               'opcode': '000000',
               'type': 'R'},
    'or': {   'funct': '100101',
              'meaning': 'Bitwise OR',
              'opcode': '000000',
              'type': 'R'},
    'ori': {   'funct': 'NA',
               'meaning': 'Bitwise OR Immediate',
               'opcode': '001101',
               'type': 'I'},
    'sb': {   'funct': 'NA',
              'meaning': 'Store Byte',
              'opcode': '101000',
              'type': 'I'},
    'sh': {   'funct': 'NA',
              'meaning': 'Store Halfword',
              'opcode': '101001',
              'type': 'I'},
    'sll': {   'funct': '000000',
               'meaning': 'Logical Shift Left',
               'opcode': '000000',
               'type': 'R'},
    'slt': {   'funct': '101010',
               'meaning': 'Set to 1 if Less Than',
               'opcode': '000000',
               'type': 'R'},
    'slti': {   'funct': 'NA',
                'meaning': 'Set to 1 if Less Than Immediate',
                'opcode': '001010',
                'type': 'I'},
    'sltiu': {   'funct': 'NA',
                 'meaning': 'Set to 1 if Less Than Unsigned Immediate',
                 'opcode': '001011',
                 'type': 'I'},
    'sltu': {   'funct': '101011',
                'meaning': 'Set to 1 if Less Than Unsigned',
                'opcode': '000000',
                'type': 'R'},
    'sra': {   'funct': '000011',
               'meaning': 'Arithmetic Shift Right (sign-extended)',
               'opcode': '000000',
               'type': 'R'},
    'srl': {   'funct': '000010',
               'meaning': 'Logical Shift Right (0-extended)',
               'opcode': '000000',
               'type': 'R'},
    'sub': {   'funct': '100010',
               'meaning': 'Subtract',
               'opcode': '000000',
               'type': 'R'},
    'subu': {   'funct': '100011',
                'meaning': 'Unsigned Subtract',
                'opcode': '000000',
                'type': 'R'},
    'sw': {   'funct': 'NA',
              'meaning': 'Store Word',
              'opcode': '101011',
              'type': 'I'},
    'xor': {   'funct': '100110',
               'meaning': 'Bitwise XOR (Exclusive-OR)',
               'opcode': '000000',
    }
}

tokens = [r.strip(',') for r in assembly_line.split(token_delimiter)]
mnemonic = tokens[0]
instruction = instructions[mnemonic]

if instruction["type"] == 'R':
    raw_registers = tokens[1:]
    registers = [registers_dict[r] for r in raw_registers]
    bin_registers = [bin(r)[2:].zfill(5) for r in registers]
    shift_amount = '00000' # TODO: not always '00000'
    #                              opcode	           rs, rt, rd      shift (shamt)	funct
    bin_instruction = instruction["opcode"] + ''.join(bin_registers) + shift_amount + instruction["funct"]
    dec_instruction = int(bin_instruction, 2)
    print('Instruction in Binary:', bin_instruction)
    print('Instruction in Decimal:', dec_instruction)